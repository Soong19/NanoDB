CS122 Assignment 2 - SQL Translation and Joins - Design Document
================================================================

Fill in answers for all questions based on your team's work on Assignment 2.

A:  Simple Planner
------------------

A1.  Without going into the details of how you handle grouping and
     aggregation or joins, list the general sequence of steps that your
     planner's makePlan() method follows to translate a SQL query into
     an execution plan.
LH:  (1) FromClause: generate plan node
     (2) WhereClause: add where clause
     (3) Grouping & Aggregation: handle_grouping and aggregation
     (4) Order By: add order-by clause
     (5) Project: add a filter for columns
     (6) Limit & Offset: add a limiter for rows

A2.  Does your planner try to simplify plans in specific circumstances,
     e.g. when a "trivial project" is used (i.e. "SELECT * FROM ...") in
     your planner?  Briefly enumerate all simplifications and optimizations
     your planner employs.
LH:  No, just normal stuff.
     (I do not think it is optimization. To be honest, I am just lazy...)

A3.  Describe how you generate the execution-plan fragment for the query's
     FromClause.  Make sure to touch on what you do in the three cases your
     planner is expected to handle - tables, subqueries in the FROM clause,
     and joins.
LH:  FromClause is used for leave node.
     (1) 0 table: Make a project node
     (2) 1 table: Make a simple file scan node
     (3) 2 or more tables: Compute join => construct a join tree

A4.  Describe how you implemented support for grouping and aggregation.
     Be sure to note any variations from the approach outlined in class,
     if there are any.
LH:  Make mapping for SELECT and HAVING before initialization of GROUP BY,
     map a ColumnValue to an AggregateFunction.


B:  Nested-Loop Join
--------------------

B1.  The join algorithm stated in class is really only suitable for
     materialized evaluation, where the entire result is generated by the
     algorithm.  It is completely unsuitable for pipelined evaluation,
     where results are generated row by row.

     Summarize how your implementation works for inner joins, using
     pseudocode to show how rows are considered and returned as the
     algorithm executes, and what state must be saved so that the
     operation can resume at the appropriate place when the next row
     must be returned.
LH:  Pseudocode:
     FUNCTION next:
          IF done: RETURN NULL
          END IF

          WHILE next_pair:
               IF canJoin:
                    RETURN joinedTuple(leftTuple, rightTuple)
               END IF
          END WHILE

          RETURN NULL

     FUNCTION next_pair:
          # leftTuple initialized in prepare phase
          IF leftTuple = NULL:
               rightTuple = rightChild.next()

               # New loop: left forward, right re-init
               WHILE rightTuple = NULL AND leftTuple != NULL:
                   rightChild.init()
                   leftTuple = leftChild.next()
               END WHILE

               RETURN leftTuple != NULL
          END IF

          DONE = TRUE;
          RETURN FALSE;

B2.  What tweaks did you need to introduce into the implementation for
     left outer joins?  Keep your answer brief, but please also be specific.
LH:  In next function, after canJoin check, check whether leftTuple is alive
     if is, emit (leftTuple, rightNullTuple)

B3.  Enumerate your nested-loop join test cases, following this form:
LH:  All in TestSimpleJoins:
     * testNormalInnerJoin: Inner Join on 2 normal tables
     * testNormalLeftOuterJoin: Left Outer Join on 2 normal tables
     * testNormalRightOuterJoin: Right Outer Join on 2 normal tables
     * testEmptyLeftOuterJoin: Left Outer Join on empty table (left) and normal
       table (right)
     * testEmptyRightOuterJoin: Right Outer Join on empty table (right) and normal
       table (left)
     * testOneRowLeft: Inner Join on table with one row (left) and table with
       multiple rows (right)
     * testOneRowRight: Inner Join on table with one row (right) and table with
       multiple rows (left)
     * testInnerJoinWhere: Cross Join with WHERE
     * testThreeInnerJoin: Inner Join on 3 tables

C:  Extra Credit [OPTIONAL]
---------------------------

If you implemented any extra-credit tasks for this assignment, describe
them here.  The description should be like this, with stuff in "<>" replaced.
(The value i starts at 1 and increments...)

D<1>:  Limit & Offset

     src: Implement LIMIT OFFSET primitive. Bulk of the work is in LimitOffsetNode
          class, the rest is in SimplePlanner (add a filter for rows if LIMIT).

     test: TestLimitOffset

D<2>:  OUTER Join, CROSS Join (same as previous join)

E:  Feedback [OPTIONAL]
-----------------------

WE NEED YOUR FEEDBACK!  Thoughtful and constructive input will help us to
improve future versions of the course.  These questions are OPTIONAL, and
your answers will not affect your grade in any way (including if you hate
everything about the assignment and databases in general, or Donnie and/or
the TAs in particular).  Feel free to answer as many or as few of them as
you wish.

E1.  What parts of the assignment were most time-consuming?  Why?

E2.  Did you find any parts of the assignment particularly instructive?
     Correspondingly, did any parts feel like unnecessary busy-work?

E3.  Did you particularly enjoy any parts of the assignment?  Were there
     any parts that you particularly disliked?

E4.  Were there any critical details that you wish had been provided with the
     assignment, that we should consider including in subsequent versions of
     the assignment?

E5.  Do you have any other suggestions for how future versions of the
     assignment can be improved?

