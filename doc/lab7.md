# Write-Ahead Logging

> [Assignment 7](http://courses.cms.caltech.edu/cs122/assignments/lab7.html):
> Write-Ahead Logging
> ([Telegraph](https://telegra.ph/Assignment-7-Write-Ahead-Logging-12-06))

* Enable transaction support in NanoDB, and disable the "flush after command"
  setting
* Update heap tuple files to log state changes to the write-ahead log
* Implement an atomic "force WAL" operation
* Implement code that enforces the Write-Ahead Logging Rule when the Buffer
  Manager evicts data pages to disk
* Implement transaction rollback using the write-ahead log
* Implement both the redo and undo phases of recovery processing

## Prepare

Transaction: `BEGIN [ WORK ]` ... `COMMIT [ WORK ]` / `ROLLBACK [ WORK ]`

---

WAL (Write-Ahead Logging): Maintain a log file separated from data files that
contains changes that txns make to database. Write to log file before applying
a change to disk.
* Buffer Pool Policy: STEAL & NO-FORCE
  * STEAL: allow an uncommitted txn to overwrite
  * NO-FORCE: not required a txn write to disk before commit => commit before
    apply to disk
* Log entry: lsn, txn-id, obj-id, before-val (undo), after-val (redo)
* `<BEGIN>` log entries... `<COMMIT>` / `<ABORT>`
* `<CHECKPOINT>` is used as the start point to analyze log

## Step #1: Enable Transaction Processing in NanoDB

> Enable transaction support in NanoDB, and disable the "flush after command"
> setting

Follow the guide, then done.

## Step #2: Add Logging to Heap Tuple Files

> Update heap tuple files to log state changes to the write-ahead log

While adding/updating/removing a tuple, storing statistics, updating
non-full-page lists, need to call `logDBPageWrite(DBPage)` in the end to ensure
writing changes to log.

## Step 3: Implement an Atomic Force-WAL Operation

> Implement an atomic "force WAL" operation

`forceWAL()` forces the WAL out to disk, at least to the specific lsn =>
1. Walk through all the files between oldNext and newNext
2. For each file, compute the start page number and the end page number. Write
   the pages to disk.
3. Update transaction state, i.e. txnNextLSN

## Step 4: Enforce the Write-Ahead Logging Rule

> Implement code that enforces the Write-Ahead Logging Rule when the Buffer
> Manager evicts data pages to disk

Every time a dirty page is evicted, we must write WAL before write the dirty
page. NanoDB uses event-handler to ensure WAL. More specifically, use the
`forceWAL()` to write logs.

## Step 5: Implement Transaction Rollback

> Implement transaction rollback using the write-ahead log

In this step, we will support such situation:
In runtime (no crash), we type `ROLLBACK` and enter, it does ROLLBACK.

From the last LSN, walk up according the prevLSN to the START record. For each
UPDATE record, restore the changes. => Very straightforward.

## Step 6: Implement Redo and Undo Processing

> Implement both the redo and undo phases of recovery processing

* Redo & Analysis Phase: For each WAL record, record START, redo UPDATE, mark
  ABORT/COMMIT. => redo all the UPDATEs even uncommitted, get the info of all
  incomplete transactions for *Undo Phase*.
* Undo Phase: For each uncommitted transaction, traverse backwards, insert ABORT
  for START, undo all uncommitted UPDATE.<br/>
  Ignore redo-only records, it is generated by ROLLBACK.
